# Read Around

This challenge requires understanding of the HTTP protocol and the socket programming.

The server's code seems to be usual HTTP parser, with exception of the assumptions written in the comments. These are all safe and unrelated to the challenge, so we should ignore that.

What we are interested however, is the processing of data content in any request other than GET. The program will read the data until the Content-Length is reached, while pushing them into the buffer with each read. This stage also ensures that the first data cannot be `fname=/`, ensuring that there should never be any root read.

However, the program makes use of ring buffer, and so if the buffer overflows, it will replace the data in front of the buffer with the new one. Not only that, the server allows for anything past the Content-Length to be read, as long as it is in the same read as the initial buffer.

Having these knowledge, we can craft a malicious HTTP request by making the Content-Length header LESS than the actual data, where the first part of the actual data contains the original request, and the rest is the forged data.

For example, to get `/flag.txt`, we can use the following payload:

`fname=flag.txt0fname=/flag.txt`

The Content-Length NEEDS to be in the same length as the forged request, and because the first half does not match the length of the forged request, we need to append it with something to match. In this case, I appended 0.

This will trick the server into reading `/flag.txt`, instead of `flag.txt`.

`fname=flag.txt0fname=/flag.txt`